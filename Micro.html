<html>
<head>
<title>8x8.space</title>
<style>

body
{
	display:	flex;
	margin:		0px;
}
canvas
{
	xflex:	1;
	/* with just flex, the canvas gets stuck too large...*/
	width:		100%;
	height:		100%;
}

button#StartXr
{
zdisplay:none !important;
	font-size:		6vmax;
	font-weight:	bold;
	font-family:	sans-serif;
	text-transform:	uppercase;
	display:	none;
	position:	absolute;
	top:		0vh;
	left:		0vw;
	width:		200px;
	height:		200px;
}

</style>


</head>
<body>
<button id="StartXr">Start XR</button>
<canvas id=Canvas></canvas>
<script type="module">
import Bootup from './Micro.js'

function StartXrCallback(Start)
{
	function OnClicked()
	{
		Button.style.display = null;
		Start();
	}
	
	const Button = document.querySelector('#StartXr');
	Button.style.display = 'block';
	Button.onclick = OnClicked;
}	

Bootup(Canvas,StartXrCallback).then(console.log).catch(console.error);


function EncodeCubeVertexes()
{
	let Positions = [];

	function vec3(a,b,c)
	{
		return [a,b,c];
	}
	//#define TRIANGLE(a,b,c)	vec3[3](a,b,c)
	function TRIANGLE(a,b,c)
	{
		return [a,b,c];
	}
	//	array of 0/1s into 32bit
	function Pack30(Bits)
	{
		let Bits32 = 0;
		for ( let i=0;	i<Bits.length;	i++ )
		{
			let Value = Bits[i] ? 1 : 0;
			let Value32 = (Value << i) >>> 0;	//	>>>0 to force switching to unsigned
			Bits32 = (Bits32|Value32) >>> 0;
		}
		return Bits32;
	}
	
	//	cube is 3positions * 2triangles * 6 faces
	//	*3 positions (0..1)
	//	108 1 or 0 = 3.375 32bits
	//	generate 1010101010101010 array which we can pack and &
	for ( let i=0;	i<3*2*6;	i++ )
	{
		let CubeVertexIndex = i;

		let TriangleIndex = Math.floor(CubeVertexIndex /3);
		let VertexIndex = Math.floor(CubeVertexIndex % 3);

		let tln = vec3(0,0,0);
		let trn = vec3(1,0,0);
		let brn = vec3(1,1,0);
		let bln = vec3(0,1,0);
		let tlf = vec3(0,0,1);
		let trf = vec3(1,0,1);
		let brf = vec3(1,1,1);
		let blf = vec3(0,1,1);
		let Triangle;
		if ( TriangleIndex==0 )	Triangle = TRIANGLE( brn, trn, tln );
		if ( TriangleIndex==1 )	Triangle = TRIANGLE( tln, bln, brn );
		if ( TriangleIndex==2 )	Triangle = TRIANGLE( trf, tlf, blf );
		if ( TriangleIndex==3 )	Triangle = TRIANGLE( blf, brf, trf );
		if ( TriangleIndex==4 )	Triangle = TRIANGLE( tln, tlf, trf );
		if ( TriangleIndex==5 )	Triangle = TRIANGLE( trf, trn, tln );
		if ( TriangleIndex==6 )	Triangle = TRIANGLE( brf, blf, bln );
		if ( TriangleIndex==7 )	Triangle = TRIANGLE( bln, brn, brf );
		if ( TriangleIndex==8 )	Triangle = TRIANGLE( tlf, tln, bln );
		if ( TriangleIndex==9 )	Triangle = TRIANGLE( bln, blf, tlf );
		if ( TriangleIndex==10 )	Triangle = TRIANGLE( trn, trf, brf );
		if ( TriangleIndex==11 )	Triangle = TRIANGLE( brf, brn, trn );
		//return Triangle[VertexIndex];
		let VertexPos = Triangle[VertexIndex];
		Positions.push(...VertexPos);
	}
	console.log(`All positions`,Positions);
	console.log(JSON.stringify(Positions));
	
	//	pack into 32bits
	//	gr: pack into 30's so data is in sets of 3 to smaller reading
	let Position30s = [];
	for ( let i=0;	i<Positions.length;	i+=30 )
	{
		let Ps = Positions.slice(i,i+30);
		let P30 = Pack30( Ps );
		Position30s.push(P30);
	}

	function Read30(Index)
	{
		let ChunkIndex = Math.floor( Index / 30 );
		let BitIndex = Index % 30;
		let Value30 = Position30s[ChunkIndex];
		let Value = (Value30 >> BitIndex) & 1;
		return Value;
	}
	
	//	print as 32bit hex
	let Position30Hexs = Position30s.map( p30 => '0x'+p30.toString(16) );
	console.log(`Position30s`,Position30Hexs);

	//	validate
	for ( let i=0;	i<Positions.length;	i++ )
	{
		let PositionDecoded = Read30(i);
		let PositionExpected = Positions[i];
		if ( PositionDecoded != PositionExpected )
			throw `Encoded/Decoded position mismatch`;
	}
	console.log(`All values matched`);
	
}
	EncodeCubeVertexes();

</script>

