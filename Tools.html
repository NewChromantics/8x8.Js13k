<html>
<head>
<style>
</style>


</head>
<body>

<script type="module">

	
function EncodeCubeVertexes()
{
	let Positions = [];

	function vec3(a,b,c)
	{
		return [a,b,c];
	}
	//#define TRIANGLE(a,b,c)	vec3[3](a,b,c)
	function TRIANGLE(a,b,c)
	{
		return [a,b,c];
	}
	//	array of 0/1s into 32bit
	function Pack30(Bits)
	{
		let Bits32 = 0;
		for ( let i=0;	i<Bits.length;	i++ )
		{
			let Value = Bits[i] ? 1 : 0;
			let Value32 = (Value << i) >>> 0;	//	>>>0 to force switching to unsigned
			Bits32 = (Bits32|Value32) >>> 0;
		}
		return Bits32;
	}
	
	//	cube is 3positions * 2triangles * 6 faces
	//	*3 positions (0..1)
	//	108 1 or 0 = 3.375 32bits
	//	generate 1010101010101010 array which we can pack and &
	for ( let i=0;	i<3*2*6;	i++ )
	{
		let CubeVertexIndex = i;

		let TriangleIndex = Math.floor(CubeVertexIndex /3);
		let VertexIndex = Math.floor(CubeVertexIndex % 3);

		let tln = vec3(0,0,0);
		let trn = vec3(1,0,0);
		let brn = vec3(1,1,0);
		let bln = vec3(0,1,0);
		let tlf = vec3(0,0,1);
		let trf = vec3(1,0,1);
		let brf = vec3(1,1,1);
		let blf = vec3(0,1,1);
		let Triangle;
		if ( TriangleIndex==0 )	Triangle = TRIANGLE( brn, trn, tln );
		if ( TriangleIndex==1 )	Triangle = TRIANGLE( tln, bln, brn );
		if ( TriangleIndex==2 )	Triangle = TRIANGLE( trf, tlf, blf );
		if ( TriangleIndex==3 )	Triangle = TRIANGLE( blf, brf, trf );
		if ( TriangleIndex==4 )	Triangle = TRIANGLE( tln, tlf, trf );
		if ( TriangleIndex==5 )	Triangle = TRIANGLE( trf, trn, tln );
		if ( TriangleIndex==6 )	Triangle = TRIANGLE( brf, blf, bln );
		if ( TriangleIndex==7 )	Triangle = TRIANGLE( bln, brn, brf );
		if ( TriangleIndex==8 )	Triangle = TRIANGLE( tlf, tln, bln );
		if ( TriangleIndex==9 )	Triangle = TRIANGLE( bln, blf, tlf );
		if ( TriangleIndex==10 )	Triangle = TRIANGLE( trn, trf, brf );
		if ( TriangleIndex==11 )	Triangle = TRIANGLE( brf, brn, trn );
		//return Triangle[VertexIndex];
		let VertexPos = Triangle[VertexIndex];
		Positions.push(...VertexPos);
	}
	console.log(`All positions`,Positions);
	console.log(JSON.stringify(Positions));
	
	//	pack into 32bits
	//	gr: pack into 30's so data is in sets of 3 to smaller reading
	let Position30s = [];
	for ( let i=0;	i<Positions.length;	i+=30 )
	{
		let Ps = Positions.slice(i,i+30);
		let P30 = Pack30( Ps );
		Position30s.push(P30);
	}

	function Read30(Index)
	{
		let ChunkIndex = Math.floor( Index / 30 );
		let BitIndex = Index % 30;
		let Value30 = Position30s[ChunkIndex];
		let Value = (Value30 >> BitIndex) & 1;
		return Value;
	}
	
	//	print as 32bit hex
	let Position30Hexs = Position30s.map( p30 => '0x'+p30.toString(16) );
	console.log(`Position30s`,Position30Hexs);

	//	validate
	for ( let i=0;	i<Positions.length;	i++ )
	{
		let PositionDecoded = Read30(i);
		let PositionExpected = Positions[i];
		if ( PositionDecoded != PositionExpected )
			throw `Encoded/Decoded position mismatch`;
	}
	console.log(`All values matched`);
	
}
EncodeCubeVertexes();




//	for readability _ is turned into a(0)
const Ghost =`Ghost
__bbbbbbb__
_bbbbbbbbb_
bb__bbb__bb
bb___bb___b
bb___bb___b
bbbbbbbbbbb
_bbbb_b_bbb
_bbbbbbbbbb
_bbbbbbbbbb
__b_b_b_b_b
__b_b_b_b_b
`;

const Cross =`Cross
____bbb____
____bbb____
bbbbbbbbbbb
bbbbbbbbbbb
____bbb____
____bbb____
____bbb____
____bbb____
____bbb____
____bbb____
`;

const Grave =`Grave
___bbbbb___
__bbbbbbb__
_bbbbbbbbb_
bbb_bbb_bbb
bbbb_b_bbbb
bbbbb_bbbbb
bbbb_b_bbbb
bbb_bbb_bbb
bbbbbbbbbbb
bbbbbbbbbbb
bbbbbbbbbbb
`;


const Grass =`Grass
___________
_____b_____
__b__b__bb_
__b__b_b___
___b_bb_bb_
_bb_b_bb___
____bbb____
_____b_____
`;


const Fence =`Fence
___________
_b___b___b_
bbb_bbb_bbb
_b___b___b_
_bbbbbbbbb_
_b___b___b_
_b___b___b_
_b___b___b_
_b___b___b_
_b___b___b_
bbbbbbbbbbb
_b___b___b_
`;

const Num0 =`Num0
_bbbb_
bb__bb
bb__bb
bb__bb
_bbbb_
`;

const Num1 =`Num1
__bb__
bbbb__
__bb__
__bb__
bbbbbb
`;

const Num2 =`Num2
_bbbb_
____bb
___bb_
_bb___
_bbbbb
`;

const Num3 =`Num3
_bbbb_
____bb
__bbb_
____bb
_bbbb_
`;

const Num4 =`Num4
___bb_
__b_b_
_b__b_
bbbbbb
____b_
`;

const Num5 =`Num5
_bbbbb
_b____
_bbbb_
____bb
_bbbb_
`;

const Num6 =`Num6
__bbb_
_bb___
bbbbb_
bb__bb
_bbbb_
`;

const Num7 =`Num7
bbbbbb
____bb
___bb_
__bb__
_bb___
`;

const Num8 =`Num8
_bbbb_
bb__bb
_bbbb_
bb__bb
_bbbb_
`;

const Num9 =`Num9
_bbbb_
bb__bb
_bbbbb
___bb_
_bbb__
`;

const Heart =`@
_bb_bb_
bbbbbbb
_bbbbb_
__bbb__
___b___
`;

const Space =`_
_
`;

const Exclamation =`!
___bb__
__bb___
__bb___
_______
__b____
`;

const Dot =`.
_______
_______
_______
__bb___
__bb___
`;


const DeadEnemy =`~
b_b_b_b
_b___b_
b_b_b_b
_______
_bbbbb_
`;


//	RLE data. but decoded into 4 component(RGBA) data for textures (then .flat(2))
//	https://levelup.gitconnected.com/having-fun-with-run-length-encoded-sprites-662d6a8147c8
function DecodeRle(rle,w=11)
{
	rle = rle.replace(/(\w)(\d+)/g, (_, char, count) =>char.repeat(count));
	return rle.split``.map((v,i)=>[i%w,i/w>>0,parseInt(v,36)-10,0]).filter(x=>!!x[2]);
}

function PadArray(a,Length,Fill)
{
	while(a.length<Length)	a.push(Fill);
	return a;
}

function EncodeSpriteToRle(SpriteString)
{
	let Rows = SpriteString.split('\n');
	let Name = Rows.shift();
	if ( Name == "_" )
		Name = " ";
	
	let rle = ``;
	let Width = Rows[0].length;
	console.log(`Sprite ${Name} Width ${Width}`);
	Rows = Rows.map( str => str.split('')).map( Row=>PadArray(Row,11,'_') .map(c => c=='_'?'a':c).join('') );
	Rows.reverse();	//	flip so we dont have to invert y in shader
	let CharString = Rows.join('');
	console.log(`CharString=${CharString}`);
	
	let CurrentChar = null;
	let CurrentCount = 0;
	function EndCurrent()
	{
		if ( CurrentChar != null )
		{
			rle += `${CurrentChar}${CurrentCount}`;
		}
		CurrentChar = null;
		CurrentCount = 0;
	}
	for ( let i=0;	i<CharString.length;	i++ )
	{
		let Char = CharString[i];
		if ( Char != CurrentChar )
			EndCurrent();
		CurrentChar = Char;
		CurrentCount++;
	}
	EndCurrent();
	//	todo: strip aN from the end, as we drop that in the decoder anyway, save 2 bytes each!
	
	const Output = {};
	Output.Name = Name;
	Output.Rle = rle;

	let Decoded = DecodeRle(rle);
	console.log(`${Name} RLE:${rle} PixelCount: ${Decoded.length}`);
	if ( Decoded.length > 128 )
		throw `Sprite too big!`;
	//	verify output
	console.log( DecodeRle(rle) );
	return Output;
}

function EncodeSpritesToCode(Sprites)
{
	Sprites = Array.from(arguments);
	const SpriteDatas = Sprites.map(EncodeSpriteToRle);
	
	function DataToCode(NameAndRle)
	{
		const Rle = NameAndRle.Rle;
		const Name = NameAndRle.Name;
		return `	"${Rle}", //	${Name}\n`;
	}
	
	function DataToMapCode(NameAndRle,Index)
	{
		const Rle = NameAndRle.Rle;
		const Name = NameAndRle.Name;
		if ( Name.length>1 )
			return null;
		return `	"${Name}":${Index},\n`;
	}

	const SpriteCode = SpriteDatas.map(DataToCode).join('');
	let Code = `const Sprites = [\n${SpriteCode}];`;
	console.log(Code);
	
	//	extra map for individual chars
	const SpriteMapCode = SpriteDatas.map(DataToMapCode).filter(x=>x!=null).join('');
	let MapCode = `const SpriteMap = {\n${SpriteMapCode}};`;
	console.log(MapCode);
	
}
	
EncodeSpritesToCode(
					Ghost,Cross,Grave,Grass,Fence,
					Num0,Num1,Num2,Num3,Num4,Num5,Num6,Num7,Num8,Num9,
					Space,Exclamation,Heart,Dot,DeadEnemy
					);
					
</script>

</html>

